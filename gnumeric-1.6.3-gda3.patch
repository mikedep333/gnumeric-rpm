--- gnumeric-1.6.3/configure.orig	2007-08-22 13:08:26.000000000 +0200
+++ gnumeric-1.6.3/configure	2007-08-22 13:08:26.000000000 +0200
@@ -22088,12 +22088,12 @@ if test -n "$PKG_CONFIG"; then
         pkg_cv_GDA_CFLAGS="$GDA_CFLAGS"
     else
         if test -n "$PKG_CONFIG" && \
-    { (echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"libgda-2.0 >= 1.3.0\"") >&5
-  ($PKG_CONFIG --exists --print-errors "libgda-2.0 >= 1.3.0") 2>&5
+    { (echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"libgda-3.0 >= 1.3.0\"") >&5
+  ($PKG_CONFIG --exists --print-errors "libgda-3.0 >= 1.3.0") 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
-  pkg_cv_GDA_CFLAGS=`$PKG_CONFIG --cflags "libgda-2.0 >= 1.3.0" 2>/dev/null`
+  pkg_cv_GDA_CFLAGS=`$PKG_CONFIG --cflags "libgda-3.0 >= 1.3.0" 2>/dev/null`
 else
   pkg_failed=yes
 fi
@@ -22106,12 +22106,12 @@ if test -n "$PKG_CONFIG"; then
         pkg_cv_GDA_LIBS="$GDA_LIBS"
     else
         if test -n "$PKG_CONFIG" && \
-    { (echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"libgda-2.0 >= 1.3.0\"") >&5
-  ($PKG_CONFIG --exists --print-errors "libgda-2.0 >= 1.3.0") 2>&5
+    { (echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"libgda-3.0 >= 1.3.0\"") >&5
+  ($PKG_CONFIG --exists --print-errors "libgda-3.0 >= 1.3.0") 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
-  pkg_cv_GDA_LIBS=`$PKG_CONFIG --libs "libgda-2.0 >= 1.3.0" 2>/dev/null`
+  pkg_cv_GDA_LIBS=`$PKG_CONFIG --libs "libgda-3.0 >= 1.3.0" 2>/dev/null`
 else
   pkg_failed=yes
 fi
@@ -22130,9 +22130,9 @@ else
         _pkg_short_errors_supported=no
 fi
         if test $_pkg_short_errors_supported = yes; then
-	        GDA_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "libgda-2.0 >= 1.3.0"`
+	        GDA_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "libgda-3.0 >= 1.3.0"`
         else
-	        GDA_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "libgda-2.0 >= 1.3.0"`
+	        GDA_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "libgda-3.0 >= 1.3.0"`
         fi
 	# Put the nasty error message in config.log where it belongs
 	echo "$GDA_PKG_ERRORS" >&5
@@ -22158,12 +22158,12 @@ if test -n "$PKG_CONFIG"; then
         pkg_cv_GNOMEDB_CFLAGS="$GNOMEDB_CFLAGS"
     else
         if test -n "$PKG_CONFIG" && \
-    { (echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"libgnomedb-2.0 >= 1.3.0\"") >&5
-  ($PKG_CONFIG --exists --print-errors "libgnomedb-2.0 >= 1.3.0") 2>&5
+    { (echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"libgnomedb-3.0 >= 1.3.0\"") >&5
+  ($PKG_CONFIG --exists --print-errors "libgnomedb-3.0 >= 1.3.0") 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
-  pkg_cv_GNOMEDB_CFLAGS=`$PKG_CONFIG --cflags "libgnomedb-2.0 >= 1.3.0" 2>/dev/null`
+  pkg_cv_GNOMEDB_CFLAGS=`$PKG_CONFIG --cflags "libgnomedb-3.0 >= 1.3.0" 2>/dev/null`
 else
   pkg_failed=yes
 fi
@@ -22176,12 +22176,12 @@ if test -n "$PKG_CONFIG"; then
         pkg_cv_GNOMEDB_LIBS="$GNOMEDB_LIBS"
     else
         if test -n "$PKG_CONFIG" && \
-    { (echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"libgnomedb-2.0 >= 1.3.0\"") >&5
-  ($PKG_CONFIG --exists --print-errors "libgnomedb-2.0 >= 1.3.0") 2>&5
+    { (echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"libgnomedb-3.0 >= 1.3.0\"") >&5
+  ($PKG_CONFIG --exists --print-errors "libgnomedb-3.0 >= 1.3.0") 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
-  pkg_cv_GNOMEDB_LIBS=`$PKG_CONFIG --libs "libgnomedb-2.0 >= 1.3.0" 2>/dev/null`
+  pkg_cv_GNOMEDB_LIBS=`$PKG_CONFIG --libs "libgnomedb-3.0 >= 1.3.0" 2>/dev/null`
 else
   pkg_failed=yes
 fi
@@ -22200,9 +22200,9 @@ else
         _pkg_short_errors_supported=no
 fi
         if test $_pkg_short_errors_supported = yes; then
-	        GNOMEDB_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "libgnomedb-2.0 >= 1.3.0"`
+	        GNOMEDB_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "libgnomedb-3.0 >= 1.3.0"`
         else
-	        GNOMEDB_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "libgnomedb-2.0 >= 1.3.0"`
+	        GNOMEDB_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "libgnomedb-3.0 >= 1.3.0"`
         fi
 	# Put the nasty error message in config.log where it belongs
 	echo "$GNOMEDB_PKG_ERRORS" >&5
--- gnumeric-1.6.3/configure.in.orig	2007-05-01 18:21:36.000000000 -0400
+++ gnumeric-1.6.3/configure.in	2007-05-01 18:22:54.000000000 -0400
@@ -369,11 +369,11 @@
 	fi
 )
 if test "$try_gda" = "true"; then
-	PKG_CHECK_MODULES(GDA, [libgda-2.0 >= 1.3.0],
+	PKG_CHECK_MODULES(GDA, [libgda-3.0 >= 1.3.0],
 		[gda_msg=yes],
 		[gda_msg="NO.  libgda problem"])
 	if test "$gda_msg" = "yes"; then
-		PKG_CHECK_MODULES(GNOMEDB, [libgnomedb-2.0 >= 1.3.0],
+		PKG_CHECK_MODULES(GNOMEDB, [libgnomedb-3.0 >= 1.3.0],
 			[gnomedb_msg="yes"],
 			[gnomedb_msg="NO. libgnomedb problem"])
 		if test "$gnomedb_msg" = "yes"; then
--- gnumeric-1.6.3/plugins/gda/plugin-gda.c.orig	2007-05-01 18:52:12.000000000 -0400
+++ gnumeric-1.6.3/plugins/gda/plugin-gda.c	2007-05-01 19:01:11.000000000 -0400
@@ -1,6 +1,8 @@
+/* vim: set sw=8: -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*- */
 /* Interface Gnumeric to Databases
  * Copyright (C) 1998,1999 Michael Lausch
  * Copyright (C) 2000-2002 Rodrigo Moya
+ * Copyright (C) 2006 Vivien Malerba
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -20,6 +22,7 @@
 #include <gnumeric-config.h>
 #include <gnumeric.h>
 #include <libgda/libgda.h>
+#include <string.h>
 #ifdef HAVE_LIBGNOMEDB
 #include <libgnomedb/gnome-db-login-dialog.h>
 #include <libgnomedb/gnome-db-login.h>
@@ -28,18 +31,116 @@
 #include "func.h"
 #include "expr.h"
 #include "value.h"
+#include "workbook.h"
+#include "sheet.h"
 #include "gnm-i18n.h"
 #include <goffice/app/go-plugin.h>
 #include <goffice/app/error-info.h>
+#include <goffice/utils/datetime.h>
+#include <goffice/utils/go-format.h>
 #include <gnm-plugin.h>
 
 GNM_PLUGIN_MODULE_HEADER;
 
-static GdaClient* connection_pool = NULL;
+static GdaClient  *connection_pool = NULL;
+static gboolean    libgda_init_done = FALSE;
+static GHashTable *cnc_hash = NULL;
+
+static GnmValue *
+gnm_value_new_from_gda (GValue const *gval,
+			GODateConventions const *date_conv)
+{
+	GnmValue *res;
+	GType t;
+
+	if (NULL == gval) 
+		return value_new_empty ();
+
+	g_return_val_if_fail (G_IS_VALUE (gval), value_new_empty ());
+
+	t = G_VALUE_TYPE (gval);
+	if (t == GDA_TYPE_SHORT)
+		return value_new_int (gda_value_get_short (gval));
+	if (t == GDA_TYPE_USHORT)
+		return value_new_int (gda_value_get_ushort (gval));
+	if (t ==  G_TYPE_DATE) {
+		res = value_new_int (datetime_g_to_serial (
+			(GDate const *) g_value_get_boxed (gval), date_conv));
+		value_set_fmt (res, go_format_default_date ());
+		return res;
+	}
+
+	if (t == GDA_TYPE_TIME) {
+		GdaTime const *time = gda_value_get_time (gval);
+		res = value_new_float ( (time->hour +
+					 (time->minute +
+					  time->second / 60.) / 60.) / 24.),
+		value_set_fmt (res, go_format_default_time ());
+		return res;
+	}
+
+	switch (t) {
+	case G_TYPE_BOOLEAN :
+		return value_new_bool (g_value_get_boolean (gval));
+
+	case G_TYPE_DOUBLE :
+		return value_new_float (g_value_get_double (gval));
+	case G_TYPE_FLOAT :
+		return value_new_float (g_value_get_float (gval));
+#if 0
+	case G_TYPE_INT64 : /* g_value_get_int64 (gval) */
+	case G_TYPE_UINT64 : /* g_value_get_uint64 (gval) */
+#endif
+	case G_TYPE_INT :
+		return value_new_int (g_value_get_int (gval));
+	case G_TYPE_UINT :
+		return value_new_int (g_value_get_uint (gval));
+
+#if 0
+	/* No way to represent a timezone, leave it as a string for now */
+	case GDA_TYPE_TIMESTAMP:
+#endif
+#if 0
+	/* Do we want to consider nested arrays ??
+	 * The rest of the system is not strong enough yet. */
+	case GDA_TYPE_LIST : {
+		GList const *ptr;
+		for (ptr = gda_value_get_list (gval) ; NULL != ptr ; ptr = ptr->next) {
+		}
+		return array;
+	}
+#endif
+
+#if 0
+	/* Use the default gvalue conversions for these */
+	case G_TYPE_CHAR :
+	case G_TYPE_UCHAR :
+	case G_TYPE_STRING :
+	case GDA_TYPE_GEOMETRIC_POINT :
+	case GDA_TYPE_BINARY :
+
+	/* this is stored as a string, let gda handle it */
+	case GDA_TYPE_NUMERIC :
+#endif
+	default :
+		break;
+	}
+
+	if (g_value_type_transformable (G_VALUE_TYPE (gval), G_TYPE_STRING)) {
+		GValue str = { 0 };
+		g_value_init (&str, G_TYPE_STRING);
+		if (g_value_transform (gval, &str))
+			return value_new_string (g_value_get_string (&str));
+		g_value_unset (&str);
+	}
+
+	return value_new_empty ();
+}
 
 static GnmValue *
 display_recordset (GdaDataModel *recset, FunctionEvalInfo *ei)
 {
+	GODateConventions const *date_conv;
 	GnmValue* array = NULL;
 	gint   col;
 	gint   row;
@@ -48,8 +149,8 @@
 
 	g_return_val_if_fail (GDA_IS_DATA_MODEL (recset), NULL);
 
-	fieldcount = gda_data_model_get_n_columns (GDA_DATA_MODEL (recset));
-	rowcount = gda_data_model_get_n_rows (GDA_DATA_MODEL (recset));
+	fieldcount = gda_data_model_get_n_columns (recset);
+	rowcount = gda_data_model_get_n_rows (recset);
 
 	/* convert the GdaDataModel in an array */
 	if (rowcount <= 0)
@@ -58,31 +159,75 @@
 	if (rowcount >= SHEET_MAX_ROWS)
 		return value_new_error (ei->pos, _("Too much data returned"));
 
+	date_conv = workbook_date_conv (ei->pos->sheet->workbook);
 	array = value_new_array_empty (fieldcount, rowcount);
 	for (row = 0; row < rowcount; row++) {
 		for (col = 0; col < fieldcount; col++) {
-			gchar *str;
-			const GdaValue *value;
-
-			value = gda_data_model_get_value_at (GDA_DATA_MODEL (recset),
-							     col, row);
-			str = gda_value_stringify ((GdaValue *) value);
-			value_array_set (array,
-					 col,
-					 row,
-					 value_new_string(str));
-
-			g_free (str);
+			value_array_set (array, col, row,
+				gnm_value_new_from_gda (
+					gda_data_model_get_value_at (recset, col, row),
+					date_conv));
 		}
 	}
 
 	return array;
 }
 
+/*
+ * Key structure and hash functions for that structure
+ */
+typedef struct {
+	gchar *dsn;
+	gchar *user;
+	gchar *pass;
+} CncKey;
+
+static guint
+cnc_key_hash_func (CncKey *key)
+{
+	guint retval = 0;
+
+	if (key->dsn)
+		retval = g_str_hash (key->dsn);
+	if (key->user)
+		retval = (retval << 4) + g_str_hash (key->user);
+	if (key->pass)
+		retval = (retval << 4) + g_str_hash (key->pass);
+
+	return retval;
+}
+
+static gboolean
+cnc_key_equal_func (CncKey *key1, CncKey *key2)
+{
+	if ((key1->dsn && !key2->dsn) ||
+	    (!key1->dsn && key2->dsn) ||
+	    (key1->dsn && key2->dsn && strcmp (key1->dsn, key2->dsn)))
+		return FALSE;
+	if ((key1->user && !key2->user) ||
+	    (!key1->user && key2->user) ||
+	    (key1->user && key2->user && strcmp (key1->user, key2->user)))
+		return FALSE;
+	if ((key1->pass && !key2->pass) ||
+	    (!key1->pass && key2->pass) ||
+	    (key1->pass && key2->pass && strcmp (key1->pass, key2->pass)))
+		return FALSE;
+	return TRUE;
+}
+
+static void
+cnc_key_free (CncKey *key)
+{
+	g_free (key->dsn);
+	g_free (key->user);
+	g_free (key->pass);
+	g_free (key);
+}
+
 static GdaConnection *
 open_connection (const gchar *dsn, const gchar *user, const gchar *password, GdaConnectionOptions options)
 {
-	GdaConnection *cnc;
+	GdaConnection *cnc = NULL;
 	gchar *real_dsn, *real_user, *real_password;
 #ifdef HAVE_LIBGNOMEDB
 	GtkWidget *dialog, *login;
@@ -91,44 +236,77 @@
 
 	/* initialize connection pool if first time */
 	if (!GDA_IS_CLIENT (connection_pool)) {
+		if (!libgda_init_done) {
+			gda_init (NULL, NULL, 0, NULL);
+			libgda_init_done = TRUE;	
+		}
 		connection_pool = gda_client_new ();
 		if (!connection_pool)
 			return NULL;
 	}
 
-#ifdef HAVE_LIBGNOMEDB
-	dialog = gnome_db_login_dialog_new (_("Database Connection"));
-	login = gnome_db_login_dialog_get_login_widget (GNOME_DB_LOGIN_DIALOG (dialog));
+	/* try to find a cnc object if we already have one */
+	if (!cnc_hash) 
+		cnc_hash = g_hash_table_new_full ((GHashFunc) cnc_key_hash_func,
+						  (GEqualFunc) cnc_key_equal_func,
+						  (GDestroyNotify) cnc_key_free,
+						  (GDestroyNotify) g_object_unref);
+	else {
+		CncKey key;
+
+		key.dsn = (gchar *) dsn;
+		key.user = (gchar *) user;
+		key.pass = (gchar *) password;
 
-	gnome_db_login_set_dsn (GNOME_DB_LOGIN (login), dsn);
-	gnome_db_login_set_username (GNOME_DB_LOGIN (login), user);
-	gnome_db_login_set_password (GNOME_DB_LOGIN (login), password);
-
-	if (gnome_db_login_dialog_run (GNOME_DB_LOGIN_DIALOG (dialog))) {
-		real_dsn = g_strdup (gnome_db_login_get_dsn (GNOME_DB_LOGIN (login)));
-		real_user = g_strdup (gnome_db_login_get_username (GNOME_DB_LOGIN (login)));
-		real_password = g_strdup (gnome_db_login_get_password (GNOME_DB_LOGIN (login)));
-
-		gtk_widget_destroy (dialog);
-	} else {
-		gtk_widget_destroy (dialog);
-		return NULL;
+		cnc = g_hash_table_lookup (cnc_hash, &key);
 	}
-#else
-	real_dsn = g_strdup (dsn);
-	real_user = g_strdup (user);
-	real_password = g_strdup (password);
-#endif
 
-	cnc = gda_client_open_connection (connection_pool, real_dsn, real_user, real_password, options, &error);
 	if (!cnc) {
-		g_warning ("Libgda error: %s\n", error->message);
-		g_error_free (error);
-	}
+		CncKey *key;
 
-	g_free (real_dsn);
-	g_free (real_user);
-	g_free (real_password);
+#ifdef HAVE_LIBGNOMEDB
+		dialog = gnome_db_login_dialog_new (_("Database Connection"));
+		login = gnome_db_login_dialog_get_login_widget (GNOME_DB_LOGIN_DIALOG (dialog));
+		
+		gnome_db_login_set_dsn (GNOME_DB_LOGIN (login), dsn);
+		gnome_db_login_set_username (GNOME_DB_LOGIN (login), user);
+		gnome_db_login_set_password (GNOME_DB_LOGIN (login), password);
+		
+		if (gnome_db_login_dialog_run (GNOME_DB_LOGIN_DIALOG (dialog))) {
+			real_dsn = g_strdup (gnome_db_login_get_dsn (GNOME_DB_LOGIN (login)));
+			real_user = g_strdup (gnome_db_login_get_username (GNOME_DB_LOGIN (login)));
+			real_password = g_strdup (gnome_db_login_get_password (GNOME_DB_LOGIN (login)));
+			
+			gtk_widget_destroy (dialog);
+		} else {
+			gtk_widget_destroy (dialog);
+			return NULL;
+		}
+#else
+		real_dsn = g_strdup (dsn);
+		real_user = g_strdup (user);
+		real_password = g_strdup (password);
+#endif
+		
+		cnc = gda_client_open_connection (connection_pool, real_dsn, real_user, real_password, options, &error);
+		if (!cnc) {
+			g_warning ("Libgda error: %s\n", error->message);
+			g_error_free (error);
+		}
+		
+		g_free (real_dsn);
+		g_free (real_user);
+		g_free (real_password);
+
+		key = g_new0 (CncKey, 1);
+		if (dsn)
+			key->dsn = g_strdup (dsn);
+		if (user)
+			key->user = g_strdup (user);
+		if (password)
+			key->pass = g_strdup (password);
+		g_hash_table_insert (cnc_hash, key, cnc);
+	}
 
 	return cnc;
 }
@@ -293,7 +471,13 @@
 }
 
 GnmFuncDescriptor gdaif_functions[] = {
-	{"execSQL", "ssss", "dsn,username,password,sql", help_execSQL, &gnumeric_execSQL, NULL, NULL, NULL },
-	{"readDBTable", "ssss", "dsn,username,password,table", help_readDBTable, &gnumeric_readDBTable, NULL, NULL, NULL },
+	{
+		"execSQL",	"ssss", "dsn,username,password,sql",
+		help_execSQL, &gnumeric_execSQL, NULL, NULL, NULL
+	},
+	{
+		"readDBTable", "ssss", "dsn,username,password,table",
+		help_readDBTable, &gnumeric_readDBTable, NULL, NULL, NULL
+	},
 	{NULL}
 };
--- gnumeric-1.6.3/plugins/gnome-db/plugin-gnomedb.c.orig	2005-03-03 02:50:56.000000000 -0500
+++ gnumeric-1.6.3/plugins/gnome-db/plugin-gnomedb.c	2007-05-01 19:02:19.000000000 -0400
@@ -1,5 +1,5 @@
 #include <gnumeric-config.h>
-#include <glib/gi18n.h>
+#include <glib/gi18n-lib.h>
 #include <glib.h>
 
 #include <workbook-control-gui.h>
